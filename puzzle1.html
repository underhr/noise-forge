<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sliding Puzzle</title>

<style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: url('assets/images/stone_wall.png') no-repeat center center fixed;
    background-size: cover;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    transition: opacity 1s ease;
  }

  #puzzle-wrapper {
    transition: opacity 1s ease;
    opacity: 1;
  }

  .fade-out {
    opacity: 0;
  }

  #puzzle-container {
    width: 440px;
    height: 440px;
    display: flex;
    flex-wrap: wrap;
  }

  .tile {
    width: 110px;
    height: 110px;
    box-sizing: border-box;
    border: 1px solid #222;
    background-image: url('assets/images/puzzle_image.png');
    background-size: 440px 440px;
    cursor: pointer;
  }

  .tile.empty {
    background-image: none;
    background-color: #333;
    cursor: default;
  }

  .solved {
    box-shadow: 0 0 20px 5px yellow;
  }

  /* ðŸ”Š VOLUME CONTROL */
  #volume-control {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0,0,0,0.6);
    padding: 8px 12px;
    border-radius: 8px;
    color: white;
    font-size: 14px;
    z-index: 9999;
  }

  #volume-slider {
    vertical-align: middle;
    margin-left: 8px;
  }
</style>
</head>

<body>

<!-- ðŸ”Š Background Audio -->
<audio id="bg-audio" loop>
  <source src="assets/audio/bg_ambient.mp3" type="audio/mpeg">
</audio>

<div id="puzzle-wrapper">
  <div id="puzzle-container"></div>
</div>

<!-- ðŸ”Š Volume Slider -->
<div id="volume-control">
  ðŸ”Š
  <input
    type="range"
    id="volume-slider"
    min="0"
    max="1"
    step="0.01"
  >
</div>

<script>
/* =======================
   ðŸ”Š AUDIO CONTINUITY
======================= */
const bgAudio = document.getElementById("bg-audio");
const volumeSlider = document.getElementById("volume-slider");

// Load saved volume
const savedVolume = localStorage.getItem("bgVolume");
bgAudio.volume = savedVolume !== null ? savedVolume : 0.4;
volumeSlider.value = bgAudio.volume;

// Resume playback time
const savedTime = localStorage.getItem("bgTime");
if (savedTime) {
  bgAudio.currentTime = parseFloat(savedTime);
}

// Start audio immediately (safe fallback)
bgAudio.play().catch(() => {});

// Save volume changes
volumeSlider.addEventListener("input", () => {
  bgAudio.volume = volumeSlider.value;
  localStorage.setItem("bgVolume", volumeSlider.value);
});

// Persist playback time
setInterval(() => {
  if (!bgAudio.paused) {
    localStorage.setItem("bgTime", bgAudio.currentTime);
  }
}, 500);


/* =======================
   ðŸ§© SLIDING PUZZLE
======================= */
const puzzleContainer = document.getElementById("puzzle-container");
const size = 4;
const totalTiles = size * size;
const blankValue = totalTiles - 1;

// Bottom-middle blank
let emptyIndex = totalTiles - size + Math.floor(size / 2);

// Build tiles
let tiles = [];
for (let i = 0; i < totalTiles; i++) tiles.push(i);

// Move blank to correct spot
[tiles[emptyIndex], tiles[blankValue]] = [tiles[blankValue], tiles[emptyIndex]];

function getAdjacent(index) {
  const row = Math.floor(index / size);
  const col = index % size;
  return [
    [row-1,col],[row+1,col],[row,col-1],[row,col+1]
  ]
  .filter(([r,c]) => r >= 0 && r < size && c >= 0 && c < size)
  .map(([r,c]) => r * size + c);
}

function scramble(moves = 150) {
  for (let i = 0; i < moves; i++) {
    const options = getAdjacent(emptyIndex);
    const move = options[Math.floor(Math.random() * options.length)];
    [tiles[emptyIndex], tiles[move]] = [tiles[move], tiles[emptyIndex]];
    emptyIndex = move;
  }
}

function isSolved() {
  for (let i = 0; i < totalTiles; i++) {
    if (i === emptyIndex) continue;
    if (tiles[i] !== i) return false;
  }
  return true;
}

function draw() {
  puzzleContainer.innerHTML = "";
  tiles.forEach((num, index) => {
    const tile = document.createElement("div");

    if (num === blankValue) {
      tile.className = "tile empty";
    } else {
      tile.className = "tile";
      const x = num % size;
      const y = Math.floor(num / size);
      tile.style.backgroundPosition = `-${x * 110}px -${y * 110}px`;
      tile.onclick = () => tryMove(index);
    }

    puzzleContainer.appendChild(tile);
  });
}

function tryMove(index) {
  if (getAdjacent(emptyIndex).includes(index)) {
    [tiles[index], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[index]];
    emptyIndex = index;
    draw();

    if (isSolved()) {
      puzzleContainer.classList.add("solved");
      document.getElementById("puzzle-wrapper").classList.add("fade-out");
      setTimeout(() => {
        window.location.href = "puzzle2.html";
      }, 1000);
    }
  }
}

scramble();
draw();
</script>

</body>
</html>
